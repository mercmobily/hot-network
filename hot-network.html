<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-form/iron-form.html">

<!--
[![Published on webcomponents.org](https://img.shields.io/badge/webcomponents.org-published-blue.svg)](https://www.webcomponents.org/element/mercmobily/hot-form)

Too many applications today have AJAX calls that are made without proper error checking. This leads to applications with strangely empty select widgets, and requiring a hard reloads in order to (hopefully) display properly. Network resiliance code is boilerplate, and it's often repeated for each call.

`hot-network` is used to wrap another element that makes AJAX calls, in order to make it Unclickable/gray while the AJAX call is going on
It will also (optionally) manage errors so that it will:
  * Give a differently themed overlay if the call didn't work
  * Give the option to retry a failed AJAX call by clicking on the overlay
  * Communicate to the user in case of problems

The overlay is fully themable with CSS mixins.

# Basic use: make contained element unclickable while AJAX is going on

All you have to do in order to get a contained element unclickable while the AJAX call is going, is wrap it with `<hot-network>`. Make sure the widget making the AJAX call is the first child of `<hot-network>`:

    <hot-network>
      <form is="iron-form" id="iron-form" method="POST" action="/stores/polymer">
        <paper-input required id="name" name="name" label="Your name"></paper-input>
        <paper-button raised type="submit">Click!</paper-button>
      </form>
    </hot-network>

`<hot-network>` will only ever have two states: "loading" (widget is overlayed) or "loaded" (no AJAX call is happening).

# Error management

You can use `<hot-network>` for widgets that are build to display data after making an AJAX call. In this case, you will want to turn on `<hot-network>`'s error management:

    <hot-network manage-errors>
      <data-displayer></data-displayer>
    </hot-network>

In this case, `<hot-network>` will be in one of three states: "loading", "loaded", "error".

When in "error" state, `<data-displayer>` will still be overlayed and unreachable. However, when tapping on the overlay, the AJAX call will be attempted again (it will re-run the `generateRequest()` method of the `<iron-ajax>` element).

If `manage-error` is on, in case of error `<hot-network>` will fire a `user-message-error` event with the message in the detail, like this: `{ message: "Error!" }`. The error message can be customised by setting the `user-message-error` attribute:

    <hot-network manage-errors user-message-error="Cannot load users!">
      <data-displayer></data-displayer>
    </hot-network>

A UI widget should pick up this message event and display it to the user.

Note that `manage-errors` doesn't make sense in a form contest because 1) A form that has an error will likely emit its own user message event 2) A form that fails doesn't need to be overlayed to retry: the user will be able to click on the "Submit" button again.

# Usage with `<hot-form>`

The `<hot-form>` element is a mixed bag: it has itself a `request` property which is the one used to _initally load_ data from the server. So, it should check for errors at load time (and reload the data if the loading call fails). However, `<hot-form>` _also_ always contains a `<form>` element that itself has a `request` property, used to submit data to the server.

In this case, you should to use two `<hot-network>` elements:

* one to gray the form while loading initial data _and_ give users a chance to re-run the request in case of errors
* one to gray out the form while the data is being submitted (errors won't be managed since it wouldn't make sense here).

So:

    <hot-network manage-errors>
      <hot-form id="hot-form" record-id="57902ef29b880cd678a3d7a9">
        <hot-network>
          <form is="iron-form" id="iron-form" method="POST" action="/stores/polymer">
            <paper-input required id="name" name="name" label="Your name"></paper-input>
            <paper-input required id="surname" name="surname" label="Your surname"></paper-input>
            <paper-input required type="number" id="age" name="age" label="Your age"></paper-input>
            <paper-toggle-button id="active" name="active" label="Active?">Active?</paper-toggle-button>
            <paper-button raised type="submit">Click!</paper-button>
          </form>
        </hot-network>
      </hot-form>
    </hot-network>

Voila': you have a form that pre-loads and submits data, and that is 100% network-aware:

* During data-loading, the form will be gray
* If data-loading fails, users will be able to re-attempt it (and view an error message)
* While submitting data to the server, the form will be gray

Note that with just a small bunch of decorating widgets, you have here a fully functional, network-aware form.

# Targeting the right `<iron-ajax>`

`<hot-network>` should always directly wrap the element that makes the requests, which must be `<hot-network>`'s first child (also called the _target element_).
If the target element has a property called `request`, that will be assumed to be an `<iron-ajax>` widget. If it doesn't, then it's assumed that the target element itself is an `<iron-ajax>` element. The name of the property to be checked can be changed with the `target-property` attribute.
So:

    <hot-network>
      <!-The property 'request' of `<data-displayer>` is assumed to be an <iron-ajax ->
      <!-If 'request' is not there, then `<data-displayer>` itself is assumed to be an <iron-ajax ->
      <data-displayer></data-displayer>
    </hot-network>

    <hot-network target-property="iaw">
      <!-The property 'iaw' of `<data-displayer>` is assumed to be an <iron-ajax ->
      <!-If 'iaw' is not there, then `<data-displayer>` itself is assumed to be an <iron-ajax ->
      <data-displayer></data-displayer>
    </hot-network>

    <hot-network>
      <!-The <iron-ajax> element doesn't have a "request" attribute. ->
      <- So, <iron-ajax> will be the target ->
      <iron-ajax></iron-ajax>
    </hot-network>

So, the `request` property always has priority.

@demo demo/index.html
-->

<dom-module id="hot-network">
  <template>
    <style>
      :host {
        display: block;
        position: relative;
      }

      :host([inline]) {
        display: inline-block;
      }

      #overlay {
        display: none; /* Hide by default */
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 1;
        text-align: center;
        transition: background var(--hot-network-transition-duration, 200ms);
        @apply(--hot-network-overlay);
      }
      #overlay.loading {
        display: block;
        color: var(--hot-network-overlay-loading-color, #666);
        /*background-color: var(--hot-network-overlay-loading-background-color, #d9dce0);*/
        background-color: var(--hot-network-overlay-loading-background-color, transparent);
        @apply(--hot-network-overlay-loading);
      }
      #overlay.loaded {
        @apply(--hot-network-overlay-loaded);
      }
      #overlay.error {
        display: block;
        cursor: pointer; /* Hint that the object is clickable */
        color: var(--hot-network-overlay-error-color, #c00);
        background-color: var(--hot-network-overlay-error-background-color, rgba(255, 0, 0, 0.25));
        @apply(--hot-network-overlay-error);
      }

      #content-wrapper {
        @apply(--hot-network-content);
      }
      #content-wrapper.loading,
      #content-wrapper.error {
        pointer-events: none;
        opacity: 0.25;
        min-height: 1.25rem; /* FIXME: find a proper value, this is made up */
      }
      #content-wrapper.loading {
        @apply(--hot-network-content-loading);
      }
      #content-wrapper.loaded {
        @apply(--hot-network-content-loaded);
      }
      #content-wrapper.error {
        @apply(--hot-network-content-error);
      }
    </style>

    <div id="overlay" on-tap="_overlayTapped" class$="{{status}}">
      {{_statusMessage(status,showLoading)}}
    </div>
    <div id="content-wrapper" class$="{{status}}">
      <slot></slot>
    </div>
  </template>

  <script>
// Monkey-patching iron-form to have this.request available
// https://github.com/PolymerElements/iron-form/issues/258
var ironForm = document.createElement('iron-form')
var proto = Object.getPrototypeOf(ironForm)
var orig = proto.attached
proto.attached = function () {
  if (!this.request) {
    this.request = document.createElement('iron-ajax')
    this.request.addEventListener('response', this._handleFormResponse.bind(this))
    this.request.addEventListener('error', this._handleFormError.bind(this))
  }
  orig.call(this)
}

/* global Polymer,customElements,Node */
class HotNetwork extends Polymer.Element {
  static get is () { return 'hot-network' }

  static get properties () {
    return {
      showLoading: {
        type: Boolean,
        value: false
      },
      manageErrors: {
        type: Boolean,
        value: false
      },
      noReloadOnTap: {
        type: Boolean,
        value: false
      },
      userMessageError: {
        type: String,
        value: 'Error!'
      },
      emitter: Object,
      immediate: Boolean,
      status: {
        type: String,
        notify: true,
        value: 'loaded',
        observer: '_statusChanged'
      },
      targetProperty: String,
      statusMessages: {
        type: Object,
        value: function () {
          return {
            'loading': 'Loading\u2026', // &hellip; equivalent
            'loaded': '',
            'error': 'An error has occurred. Click here to try again.'
          }
        }
      }
    }
  }

  _overlayTapped (e) {
    if (!this.noReloadOnTap) {
      e.stopPropagation()
      e.preventDefault()
      if (this.status === 'error') {
        this.emitter.generateRequest()
      }
    }
  }

  _statusChanged (s) {
    this.updateStyles()
  }

  _statusMessage (status, showLoading) {
    if (!this.statusMessages) return '' /* Was undefined on startup */
    if (status === 'loading' && !showLoading) return ''

    return this.statusMessages[status]
  }

  _findFirstChildElement () {
    var firstElement = Polymer.FlattenedNodesObserver.getFlattenedNodes(this).find(el => el.nodeType === Node.ELEMENT_NODE)
    var emitterProperty = this.targetProperty || 'request'
    if (firstElement) {
      if (firstElement[ emitterProperty ]) {
        return firstElement[emitterProperty]
      } else {
        return firstElement.request ? firstElement.request : firstElement
      }
    } else {
      throw new Error('hot-network could not find the element to be decorated')
    }
  }

  connectedCallback () {
    super.connectedCallback()
    var t = this

    // Function that actually does the finding and attaching
    function findTargetAndListen () {
      t.emitter = t._findFirstChildElement()
      if (t.emitter) {
        t.emitter.addEventListener('error', t._catcher.bind(t))
        t.emitter.addEventListener('response', t._catcher.bind(t))
        t.emitter.addEventListener('request', t._catcher.bind(t))
      }
    }

    if (this.immediate) {
      findTargetAndListen()
    } else {
      setTimeout(function () {
        findTargetAndListen()
      }, 0)
    }
  }

  detachedCallback () {
    super.detachedCallback()
    if (this.emitter) {
      this.emitter.removeEventListener('error', this._catcher.bind(this))
      this.emitter.removeEventListener('response', this._catcher.bind(this))
      this.emitter.removeEventListener('request', this._catcher.bind(this))
    }
  }

  _catcher (e) {
    // Errors will be ignored, meaning that "error" will be the same as
    // "loaded".

    // Normalise the name, so that only the last work is used.
    // E.g. 'iron-ajax-error' -> 'error'
    var type = e.type.split(/[^a-zA-Z]/).pop()

    if (this.manageErrors) {
      this.status = ({
        error: 'error',
        request: 'loading',
        response: 'loaded'
      }[type]) || 'error'

      // if there is an error, fire a global error message
      if (this.status === 'error' && this.userMessageError) {
        this.fire('user-message-error', {
          message: this.userMessageError,
          originalEvent: e
        })
      }
    } else {
      this.status = ({
        error: 'loaded',
        request: 'loading',
        response: 'loaded'
      }[type]) || 'loaded'
    }
  }
}
customElements.define(HotNetwork.is, HotNetwork)
  </script>
</dom-module>
