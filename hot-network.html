<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../hot-deep-target-behavior/hot-deep-target-behavior.html">

<!--
Too many applications today have AJAX calls that are made without proper error checking. This leads to applications with strangely empty select widgets, and requiring a hard reloads in orderto (hopefully) display properly. Network resiliance code is boilerplate, and it's often repeated for each call.

`hot-network` is used to wrap another element that makes AJAX calls, in order to make it

* Unclickable/gray while the AJAX call is going on
* (Optionally) manage errors in case so that it will:
  * Give a differently themed overlay if the call didn't work
  * Give the option to retry a failed AJAX call by clicking on the overlay
  * Communicate to the user in case of problems

The overlay is fully themable with CSS mixins.

# Basic use: make contained element unclickable while AJAX is going on

All you have to do in order to get a contained element unclickable while the AJAX call is going, is wrap it with `<hot-network>`. Make sure the widget making the AJAX call is the first child of `<hot-network>`:

    <hot-network>
      <form is="iron-form" id="iron-form" method="POST" action="/stores/polymer">
        <paper-input required id="name" name="name" label="Your name"></paper-input>
        <paper-button raised type="submit">Click!</paper-button>
      </form>
    </hot-network>

`<hot-network>` will only ever have two states: "loading" (widget is overlayed) or "loaded" (no AJAX call is happening).

# Error management

You can use `<hot-network>` for widgets that are build to display data after making an AJAX call. In this case, you will want to turn on `<hot-network>`'s error management:

    <hot-network manage-errors>
      <data-displayer></data-displayer>
    </hot-network>

In this case, `<hot-network>` will be in one of three states: "loading", "loaded", "error".

When in "error" state, `<data-displayer>` will still be overlayed and unreachable. However, when tapping on the overlay, the AJAX call will be attempted again (it will re-run the `generateRequest()` method of the `<iron-ajax>` element).

If `manage-error` is on, in case of error `<hot-network>` will fire a `user-message-error` event with the message in the detail, like this: `{ message: "Error!" }`. The error message can be customised by setting the `user-message-error` attribute:

    <hot-network manage-errors user-message-error="Cannot load users!">
      <data-displayer></data-displayer>
    </hot-network>

A UI widget should pick up this message event and display it to the user.

Note that `manage-errors` doesn't make sense in a form contest because 1) A form that has an error will likely emit its own user message event 2) A form that fails doesn't need to be overlayed to retry: the user will be able to click on the "Submit" button again.

# Usage with `<hot-form>`

The `<hot-form>` element is a mixed bag: it has itself a `request` property which is the one used to _initally load_ data from the server. So, it should check for errors at load time (and reload the data if the loading call fails). However, `<hot-form>` _also_ always contains a `<form>` element that itself has a `request` property, used to submit data to the server.

In this case, you a recommended to use two `<hot-network>` elements:

* one to gray the form while loading initial data _and_ give users a chance to re-run the request in case of errors
* one to gray out the form while the data is being submitted (errors won't be managed since it wouldn't make sense here).

So:

    <hot-network manage-errors>
      <hot-form id="hot-form" record-id="57902ef29b880cd678a3d7a9">
        <hot-network>
          <form is="iron-form" id="iron-form" method="POST" action="/stores/polymer">
            <paper-input required id="name" name="name" label="Your name"></paper-input>
            <paper-input required id="surname" name="surname" label="Your surname"></paper-input>
            <paper-input required type="number" id="age" name="age" label="Your age"></paper-input>
            <paper-toggle-button id="active" name="active" label="Active?">Active?</paper-toggle-button>
            <paper-button raised type="submit">Click!</paper-button>
          </form>
        </hot-network>
      </hot-form>
    </hot-network>

Voila': you have a form that pre-loads and submits data, and that is 100% network-aware:

* During data-loading, the form will be gray
* If data-loading fails, users will be able to re-attempt it (and view an error message)
* While submitting data to the server, the form will be gray

Note that with just a small bunch of decorating widgets, you have here a fully functional, network-aware form.

# Targeting the right `<iron-ajax>`

`<hot-network>` should always directly wrap the element that makes the requests, which must be `<hot-network>`'s first child (also called the _target element_).
If the target element has a property called `request`, that will be assumed to be an `<iron-ajax>` widget. If it doesn't, then it's assumed that the target element itself is an `<iron-ajax>` element. The name of the property to be checked can be changed with the `target-property` attribute.
So:

    <hot-network>
      <!-The property 'request' of `<data-displayer>` is assumed to be an <iron-ajax ->
      <!-If 'request' is not there, then `<data-displayer>` itself is assumed to be an <iron-ajax ->
      <data-displayer></data-displayer>
    </hot-network>

    <hot-network target-property="iaw">
      <!-The property 'iaw' of `<data-displayer>` is assumed to be an <iron-ajax ->
      <!-If 'iaw' is not there, then `<data-displayer>` itself is assumed to be an <iron-ajax ->
      <data-displayer></data-displayer>
    </hot-network>

    <hot-network>
      <!-The <iron-ajax> element doesn't have a "request" attribute. ->
      <- So, <iron-ajax> will be the target ->
      <iron-ajax></iron-ajax>
    </hot-network>

So, the `request` property always has priority.

It's possible to specify the target ID directly and have the target further in the DOM, rather than being `<hot-network>`'s first child:

    <hot-network target-id="displayer">
      <div>
        <data-displayer id="displayer"></data-displayer>
      </div>
    </hot-network>

@demo demo/index.html
-->

<dom-module id="hot-network">
  <template>
    <style>
      :host {
        display: block;
        position: relative;
      }

      ;
      /** Standard overlay CSS.
       * The only "strange" part is the z-index, which needs to be high
       * so that the overlay catches everything
     */

      #overlay {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        padding: 10px;
        z-index: 9999;
        -webkit-transition: background 0.5s linear;
        -moz-transition: background 0.5s linear;
        -ms-transition: background 0.5s linear;
        -o-transition: background 0.5s linear;
        transition: background 0.5s linear;
        border-radius: 25px;
        @apply(--hot-network-overlay);
      }

      ;
      #overlay.loading {
        opacity: 0.2;
        background-color: grey;
        @apply(--hot-network-overlay-loading);
      }

      #overlay.loaded {
        background-color: none;
        opacity: 0.2;
        z-index: 0;
        @apply(--hot-network-overlay-loaded);
      }

      #overlay.error {
        opacity: 0.2;
        background-color: red;
        @apply(--hot-network-overlay-error);
      }

      #content-wrapper {
        padding: 10px;
        @apply(--hot-network-content-wrapper);
      }

      ;
      #content-wrapper.loading {
        opacity: 0.3;
        @apply(--hot-network-content-wrapper-loading);
      }

      #content-wrapper.loaded {
        @apply(--hot-network-content-wrapper-loaded);
      }

      #content-wrapper.error {
        opacity: 0.3;
        @apply(--hot-network-content-wrapper-error);
      }
    </style>

    <div>
      <div id="overlay" on-tap="_overlayTapped" class$="{{status}}"></div>
      <div id="content-wrapper" class$="{{status}}">
        <content></content>
      </div>
    </div>

  </template>

  <script>
    Polymer({

      is: 'hot-network',

      properties: {

        manageErrors: {
          type: Boolean,
          value: false
        },

        noReloadOnTap: {
          type: Boolean,
          value: false
        },

        userMessageError: {
          type: String,
          value: "Error!"
        },

        emitter: Object,

        status: {
          type: String,
          notify: true,
          value: "loaded",
          observer: "_statusChanged",
        },

        targetId: String,
        targetProperty: String,
      },

      _overlayTapped: function(e) {
        if (!this.noReloadOnTap) {
          e.stopPropagation();
          e.preventDefault();
          if (this.status == 'error') {
            this.emitter.generateRequest();
          }
        }
      },

      _statusChanged: function(s) {
        this.updateStyles();
      },

      _findFirstChildElement: function() {
        var firstElement = this.getEffectiveChildren()[0];
        var emitterProperty = this.targetProperty || 'request';
        if (firstElement) {
          if (firstElement[ emitterProperty ]) {
            return firstElement[emitterProperty]
          } else {
            return firstElement.request ? firstElement.request : firstElement;
          }
        }
      },

      _findEmitterNode: function(node) {
        var emitter = this.queryEffectiveChildrenDeep("#" + this.targetId, true, 'hot-network');
        var emitterProperty = (this.targetProperty || 'request');
        return emitter[emitterProperty] ? emitter[emitterProperty] : emitter;
      },

      attached: function() {

        this.async(function() {

          if (this.targetId) {
            this.emitter = this._findEmitterNode();
          } else {
            this.emitter = this._findFirstChildElement();
          }

          if (this.emitter) {
            this.listen(this.emitter, "error", "_catcher");
            this.listen(this.emitter, "response", "_catcher");
            this.listen(this.emitter, "request", "_catcher");
          }
        });
      },

      detached: function() {
        if (this.emitter) {
          this.unlisten(this.emitter, "error", "_catcher");
          this.unlisten(this.emitter, "response", "_catcher");
          this.unlisten(this.emitter, "request", "_catcher");
        }
      },

      _catcher: function(e) {

        // Errors will be ignored, meaning that "error" will be the same as
        // "loaded".
        if (this.manageErrors) {

          this.status = ({
            error: 'error',
            request: 'loading',
            response: 'loaded',
          }[e.type]) || "error";

          // if there is an error, fire a global error message
          if (this.status === "error" && this.userMessageError) {
            this.fire('user-message-error', {
              message: this.userMessageError
            });
          }

        } else {
          this.status = ({
            error: 'loaded',
            request: 'loading',
            response: 'loaded',
          }[e.type]) || "loaded";

        }
      }
    });
  </script>
</dom-module>
